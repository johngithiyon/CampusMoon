<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiparty Video Chat</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #4a6cf7;
      --secondary-color: #6c757d;
      --success-color: #28a745;
      --danger-color: #dc3545;
      --dark-color: #343a40;
      --light-color: #f8f9fa;
      --background-color: #f4f7fe;
      --card-background: #ffffff;
      --border-radius: 12px;
      --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: var(--background-color);
      color: #333;
      line-height: 1.6;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px 0;
    }

    header h1 {
      color: var(--primary-color);
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    header p {
      color: var(--secondary-color);
      font-size: 1.1rem;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      gap: 30px;
    }

    .video-section {
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: var(--box-shadow);
    }

    .video-section h2 {
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--dark-color);
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .video-section h2 i {
      color: var(--primary-color);
    }

    .video-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .video-container {
      position: relative;
      border-radius: var(--border-radius);
      overflow: hidden;
      background-color: #000;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
      aspect-ratio: 16/9;
    }

    .video-container:hover {
      transform: translateY(-5px);
    }

    .video-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .video-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
      color: white;
      padding: 15px 10px 10px;
      font-size: 0.9rem;
    }

    .local-video .video-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .video-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
    }

    .control-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .control-btn:hover {
      background-color: rgba(0, 0, 0, 0.7);
    }

    .muted-audio, .muted-video {
      background-color: var(--danger-color);
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 20px;
      padding: 15px;
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: var(--success-color);
    }

    .status-indicator.connecting {
      background-color: #ffc107;
    }

    .status-indicator.disconnected {
      background-color: var(--danger-color);
    }

    .participant-count {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--secondary-color);
    }

    .action-buttons {
      display: flex;
      gap: 15px;
    }

    .btn {
      padding: 10px 20px;
      border-radius: 50px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s;
    }

    .btn-primary {
      background-color: var(--primary-color);
      color: white;
    }

    .btn-primary:hover {
      background-color: #3a5ad9;
    }

    .btn-danger {
      background-color: var(--danger-color);
      color: white;
    }

    .btn-danger:hover {
      background-color: #bd2130;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--secondary-color);
    }

    .empty-state i {
      font-size: 3rem;
      margin-bottom: 15px;
      color: #dee2e6;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .video-grid {
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      }
      
      .status-bar {
        flex-direction: column;
        gap: 15px;
        text-align: center;
      }
      
      .action-buttons {
        width: 100%;
        justify-content: center;
      }
    }

    @media (max-width: 480px) {
      header h1 {
        font-size: 2rem;
      }
      
      .video-grid {
        grid-template-columns: 1fr;
      }
      
      .btn {
        padding: 8px 16px;
        font-size: 0.9rem;
      }
    }

    /* Animation for new participants */
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }

    .video-container.new {
      animation: fadeIn 0.5s ease;
    }

    /* Connection quality indicator */
    .connection-quality {
      display: flex;
      gap: 3px;
      margin-top: 5px;
    }

    .quality-bar {
      width: 4px;
      height: 4px;
      border-radius: 1px;
      background-color: rgba(255, 255, 255, 0.3);
    }

    .quality-bar.active {
      background-color: var(--success-color);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Multiparty Video Chat</h1>
      <p>Connect with multiple participants in real-time</p>
    </header>

    <div class="main-content">
      <div class="video-section">
        <h2><i class="fas fa-user"></i> Your Video</h2>
        <div class="video-grid">
          <div class="video-container local-video">
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="video-info">
              <span>You</span>
              <div class="video-controls">
                <button class="control-btn toggle-audio" title="Mute/Unmute Audio">
                  <i class="fas fa-microphone"></i>
                </button>
                <button class="control-btn toggle-video" title="Enable/Disable Video">
                  <i class="fas fa-video"></i>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="video-section">
        <h2><i class="fas fa-users"></i> Participants</h2>
        <div id="videos" class="video-grid">
          <div class="empty-state">
            <i class="fas fa-user-friends"></i>
            <p>Waiting for other participants to join...</p>
          </div>
        </div>
      </div>

      <div class="status-bar">
        <div class="connection-status">
          <div class="status-indicator" id="connectionStatus"></div>
          <span id="statusText">Connecting...</span>
        </div>
        
        <div class="participant-count">
          <i class="fas fa-users"></i>
          <span id="participantCount">1 participant</span>
        </div>
        
        <div class="action-buttons">
          <button class="btn btn-danger" id="leaveCall">
            <i class="fas fa-phone-slash"></i> Leave Call
          </button>
          <button class="btn btn-primary" id="shareScreen">
            <i class="fas fa-desktop"></i> Share Screen
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const localVideo = document.getElementById("localVideo");
    const videosContainer = document.getElementById("videos");
    const connectionStatus = document.getElementById("connectionStatus");
    const statusText = document.getElementById("statusText");
    const participantCount = document.getElementById("participantCount");
    const leaveCallBtn = document.getElementById("leaveCall");
    const shareScreenBtn = document.getElementById("shareScreen");
    const toggleAudioBtn = document.querySelector('.toggle-audio');
    const toggleVideoBtn = document.querySelector('.toggle-video');
    
    let localStream;
    let peers = {}; // peerId -> RTCPeerConnection
    let pendingPeers = []; // peers received before localStream ready
    let isScreenSharing = false;
    let ws;

    // Initialize the application
    function init() {
      connectWebSocket();
      setupEventListeners();
      getLocalMedia();
    }

    // Connect to WebSocket server
    function connectWebSocket() {
      try {
        ws = new WebSocket("ws://" + location.host + "/ws");
        updateConnectionStatus('connecting');
        
        ws.onopen = () => {
          console.log("WebSocket connection established");
          updateConnectionStatus('connected');
        };
        
        ws.onclose = () => {
          console.log("WebSocket connection closed");
          updateConnectionStatus('disconnected');
          // Try to reconnect after 3 seconds
          setTimeout(connectWebSocket, 3000);
        };
        
        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          updateConnectionStatus('error');
        };
        
        // Handle signaling messages
        ws.onmessage = handleSignalingMessage;
        
      } catch (error) {
        console.error("Failed to connect WebSocket:", error);
        updateConnectionStatus('error');
      }
    }

    // Set up UI event listeners
    function setupEventListeners() {
      leaveCallBtn.addEventListener('click', leaveCall);
      shareScreenBtn.addEventListener('click', toggleScreenShare);
      toggleAudioBtn.addEventListener('click', toggleAudio);
      toggleVideoBtn.addEventListener('click', toggleVideo);
    }

    // Get local camera/mic
    function getLocalMedia() {
      navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(stream => {
          localVideo.srcObject = stream;
          localStream = stream;
          updateMediaControls();

          // Create any pending peer connections
          pendingPeers.forEach(peerId => createPeerConnection(peerId, true));
          pendingPeers = [];
        })
        .catch(err => {
          console.error("getUserMedia error:", err);
          statusText.textContent = "Unable to access camera/microphone";
        });
    }

    // Handle signaling messages
    async function handleSignalingMessage(event) {
      const msg = JSON.parse(event.data);

      switch(msg.type) {
        case "existing-peers":
          msg.peers.forEach(peerId => {
            if(localStream) {
              createPeerConnection(peerId, true);
            } else {
              pendingPeers.push(peerId);
            }
          });
          updateParticipantCount();
          break;
          
        case "new-peer":
          if(localStream) {
            createPeerConnection(msg.id, false);
          } else {
            pendingPeers.push(msg.id);
          }
          updateParticipantCount();
          break;
          
        case "offer":
          const pc = createPeerConnection(msg.from, false);
          await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ type: "answer", answer, to: msg.from }));
          break;
          
        case "answer":
          if (peers[msg.from]) {
            await peers[msg.from].setRemoteDescription(new RTCSessionDescription(msg.answer));
          }
          break;
          
        case "ice-candidate":
          if (peers[msg.from]) {
            peers[msg.from].addIceCandidate(new RTCIceCandidate(msg.candidate));
          }
          break;
          
        case "peer-disconnected":
          removePeerConnection(msg.id);
          updateParticipantCount();
          break;
      }
    }

    // Create peer connection
    function createPeerConnection(peerId, isOfferer) {
      if(peers[peerId]) return peers[peerId];

      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" }
        ]
      });

      // Add local tracks
      if(localStream) {
        localStream.getTracks().forEach(track => {
          if (localStream.getTracks().includes(track)) {
            pc.addTrack(track, localStream);
          }
        });
      }

      // Send ICE candidates
      pc.onicecandidate = event => {
        if(event.candidate) {
          ws.send(JSON.stringify({ type: "ice-candidate", candidate: event.candidate, to: peerId }));
        }
      };

      // Display remote stream
      pc.ontrack = event => {
        let videoElement = document.getElementById("remote-" + peerId);
        if(!videoElement) {
          // Remove empty state if it exists
          const emptyState = videosContainer.querySelector('.empty-state');
          if (emptyState) emptyState.remove();
          
          videoElement = document.createElement('video');
          videoElement.id = "remote-" + peerId;
          videoElement.autoplay = true;
          videoElement.playsInline = true;
          
          const videoContainer = document.createElement('div');
          videoContainer.className = 'video-container new';
          videoContainer.appendChild(videoElement);
          
          const videoInfo = document.createElement('div');
          videoInfo.className = 'video-info';
          videoInfo.innerHTML = `<span>Participant ${peerId}</span>`;
          
          videoContainer.appendChild(videoInfo);
          videosContainer.appendChild(videoContainer);
          
          // Remove the 'new' class after animation completes
          setTimeout(() => videoContainer.classList.remove('new'), 500);
        }
        videoElement.srcObject = event.streams[0];
      };

      pc.onconnectionstatechange = () => {
        console.log(`Connection state with ${peerId}: ${pc.connectionState}`);
      };

      peers[peerId] = pc;

      // Create offer if needed
      if(isOfferer) {
        pc.createOffer().then(offer => {
          pc.setLocalDescription(offer).then(() => {
            ws.send(JSON.stringify({ type: "offer", offer, to: peerId }));
          });
        });
      }

      return pc;
    }

    // Remove peer connection
    function removePeerConnection(peerId) {
      if(peers[peerId]) {
        peers[peerId].close();
        delete peers[peerId];
      }
      
      const videoElement = document.getElementById("remote-" + peerId);
      if(videoElement) {
        videoElement.closest('.video-container').remove();
      }
      
      // Show empty state if no participants
      if(videosContainer.children.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        emptyState.innerHTML = `
          <i class="fas fa-user-friends"></i>
          <p>Waiting for other participants to join...</p>
        `;
        videosContainer.appendChild(emptyState);
      }
    }

    // Toggle audio mute/unmute
    function toggleAudio() {
      if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        if (audioTracks.length > 0) {
          const newState = !audioTracks[0].enabled;
          audioTracks[0].enabled = newState;
          
          toggleAudioBtn.classList.toggle('muted-audio', !newState);
          toggleAudioBtn.innerHTML = newState ? 
            '<i class="fas fa-microphone"></i>' : 
            '<i class="fas fa-microphone-slash"></i>';
        }
      }
    }

    // Toggle video on/off
    function toggleVideo() {
      if (localStream) {
        const videoTracks = localStream.getVideoTracks();
        if (videoTracks.length > 0) {
          const newState = !videoTracks[0].enabled;
          videoTracks[0].enabled = newState;
          
          toggleVideoBtn.classList.toggle('muted-video', !newState);
          toggleVideoBtn.innerHTML = newState ? 
            '<i class="fas fa-video"></i>' : 
            '<i class="fas fa-video-slash"></i>';
        }
      }
    }

    // Toggle screen sharing
    function toggleScreenShare() {
      if (isScreenSharing) {
        // Switch back to camera
        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
          .then(stream => {
            replaceStream(stream);
            localStream = stream;
            isScreenSharing = false;
            shareScreenBtn.innerHTML = '<i class="fas fa-desktop"></i> Share Screen';
            shareScreenBtn.classList.remove('btn-danger');
          })
          .catch(err => console.error("Error switching back to camera:", err));
      } else {
        // Switch to screen share
        navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })
          .then(stream => {
            replaceStream(stream);
            isScreenSharing = true;
            shareScreenBtn.innerHTML = '<i class="fas fa-times"></i> Stop Sharing';
            shareScreenBtn.classList.add('btn-danger');
            
            // Handle when the user stops screen sharing
            stream.getVideoTracks()[0].onended = () => {
              if (isScreenSharing) {
                toggleScreenShare();
              }
            };
          })
          .catch(err => {
            console.error("Error sharing screen:", err);
          });
      }
    }

    // Replace the current stream with a new one
    function replaceStream(newStream) {
      // Update local video element
      localVideo.srcObject = newStream;
      
      // Update all peer connections
      Object.values(peers).forEach(pc => {
        // Remove existing tracks
        const sender = pc.getSenders();
        sender.forEach(s => {
          if (s.track && s.track.kind === 'video') {
            pc.removeTrack(s);
          }
        });
        
        // Add new tracks
        newStream.getTracks().forEach(track => {
          pc.addTrack(track, newStream);
        });
      });
      
      // Close the old stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      
      localStream = newStream;
      updateMediaControls();
    }

    // Update media control buttons based on current state
    function updateMediaControls() {
      if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        const videoTracks = localStream.getVideoTracks();
        
        if (audioTracks.length > 0) {
          const audioEnabled = audioTracks[0].enabled;
          toggleAudioBtn.classList.toggle('muted-audio', !audioEnabled);
          toggleAudioBtn.innerHTML = audioEnabled ? 
            '<i class="fas fa-microphone"></i>' : 
            '<i class="fas fa-microphone-slash"></i>';
        }
        
        if (videoTracks.length > 0) {
          const videoEnabled = videoTracks[0].enabled;
          toggleVideoBtn.classList.toggle('muted-video', !videoEnabled);
          toggleVideoBtn.innerHTML = videoEnabled ? 
            '<i class="fas fa-video"></i>' : 
            '<i class="fas fa-video-slash"></i>';
        }
      }
    }

    // Leave the call
    function leaveCall() {
      // Close all peer connections
      Object.keys(peers).forEach(peerId => {
        removePeerConnection(peerId);
      });
      
      // Close local stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      
      // Close WebSocket connection
      if (ws) {
        ws.close();
      }
      
      // Update UI
      updateConnectionStatus('disconnected');
      statusText.textContent = "Call ended";
      participantCount.textContent = "0 participants";
      
      // Disable buttons
      leaveCallBtn.disabled = true;
      shareScreenBtn.disabled = true;
    }

    // Update connection status indicator
    function updateConnectionStatus(status) {
      connectionStatus.className = 'status-indicator';
      
      switch(status) {
        case 'connected':
          connectionStatus.classList.add('connected');
          statusText.textContent = "Connected";
          break;
        case 'connecting':
          connectionStatus.classList.add('connecting');
          statusText.textContent = "Connecting...";
          break;
        case 'disconnected':
        case 'error':
          connectionStatus.classList.add('disconnected');
          statusText.textContent = "Disconnected";
          break;
      }
    }

    // Update participant count
    function updateParticipantCount() {
      const count = Object.keys(peers).length + 1; // +1 for local participant
      participantCount.textContent = `${count} participant${count !== 1 ? 's' : ''}`;
    }

    // Initialize the app when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>