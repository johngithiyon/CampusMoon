<!DOCTYPE html>
<html>
<head>
  <title>Multiparty Video Chat</title>
  <style>
    video { width: 200px; margin: 5px; border: 1px solid #ccc; }
    #videos { display: flex; flex-wrap: wrap; }
  </style>
</head>
<body>
  <h2>Local Video</h2>
  <video id="localVideo" autoplay muted playsinline></video>

  <h2>Remote Videos</h2>
  <div id="videos"></div>

  <script>
    const localVideo = document.getElementById("localVideo");
    const videosContainer = document.getElementById("videos");
    let localStream;
    const peers = {}; // peerId -> RTCPeerConnection
    let pendingPeers = []; // peers received before localStream ready

    const ws = new WebSocket("ws://" + location.host + "/ws");

    // 1. Get local camera/mic
    navigator.mediaDevices.getUserMedia({ video: true, audio: true })
      .then(stream => {
        localVideo.srcObject = stream;
        localStream = stream;

        // Create any pending peer connections
        pendingPeers.forEach(peerId => createPeerConnection(peerId, true));
        pendingPeers = [];
      })
      .catch(err => console.error("getUserMedia error:", err));

    // 2. Handle signaling messages
    ws.onmessage = async (event) => {
      const msg = JSON.parse(event.data);

      if(msg.type === "existing-peers") {
        msg.peers.forEach(peerId => {
          if(localStream) {
            createPeerConnection(peerId, true);
          } else {
            pendingPeers.push(peerId);
          }
        });
      }

      if(msg.type === "new-peer") {
        if(localStream) {
          createPeerConnection(msg.id, false);
        } else {
          pendingPeers.push(msg.id);
        }
      }

      if(msg.type === "offer") {
        const pc = createPeerConnection(msg.from, false);
        await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify({ type: "answer", answer, to: msg.from }));
      }

      if(msg.type === "answer") {
        const pc = peers[msg.from];
        await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
      }

      if(msg.type === "ice-candidate") {
        const pc = peers[msg.from];
        if(pc) pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
      }
    };

    // 3. Create peer connection
    function createPeerConnection(peerId, isOfferer) {
      if(peers[peerId]) return peers[peerId];

      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      // Add local tracks
      if(localStream) {
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      }

      // Send ICE candidates
      pc.onicecandidate = event => {
        if(event.candidate) {
          ws.send(JSON.stringify({ type: "ice-candidate", candidate: event.candidate, to: peerId }));
        }
      };

      // Display remote stream
      pc.ontrack = event => {
        let video = document.getElementById("remote-" + peerId);
        if(!video) {
          video = document.createElement("video");
          video.id = "remote-" + peerId;
          video.autoplay = true;
          video.playsInline = true;
          videosContainer.appendChild(video);
        }
        video.srcObject = event.streams[0];
      };

      peers[peerId] = pc;

      // Create offer if needed
      if(isOfferer) {
        pc.createOffer().then(offer => {
          pc.setLocalDescription(offer).then(() => {
            ws.send(JSON.stringify({ type: "offer", offer, to: peerId }));
          });
        });
      }

      return pc;
    }
  </script>
</body>
</html>
