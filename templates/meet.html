<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiparty Video Chat with Whiteboard & Chat</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Existing CSS remains the same, just adding poll-specific styles -->
  <style>
    /* All existing CSS remains unchanged */
    :root {
      --primary-color: #4a6cf7;
      --secondary-color: #6c757d;
      --success-color: #28a745;
      --danger-color: #dc3545;
      --warning-color: #ffc107;
      --dark-color: #343a40;
      --light-color: #f8f9fa;
      --background-color: #f4f7fe;
      --card-background: #ffffff;
      --border-radius: 12px;
      --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: var(--background-color);
      color: #333;
      line-height: 1.6;
      padding: 20px;
      min-height: 100vh;
      position: relative;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px 0;
    }

    header h1 {
      color: var(--primary-color);
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    header p {
      color: var(--secondary-color);
      font-size: 1.1rem;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      gap: 30px;
    }

    .video-section {
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      padding: 20px;
      box-shadow: var(--box-shadow);
    }

    .video-section h2 {
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--dark-color);
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .video-section h2 i {
      color: var(--primary-color);
    }

    .video-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .video-container {
      position: relative;
      border-radius: var(--border-radius);
      overflow: hidden;
      background-color: #000;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
      aspect-ratio: 16/9;
    }

    .video-container:hover {
      transform: translateY(-5px);
    }

    .video-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .video-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
      color: white;
      padding: 15px 10px 10px;
      font-size: 0.9rem;
    }

    .local-video .video-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .video-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
    }

    .control-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .control-btn:hover {
      background-color: rgba(0, 0, 0, 0.7);
    }

    .muted-audio, .muted-video {
      background-color: var(--danger-color);
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 20px;
      padding: 15px;
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: var(--success-color);
    }

    .status-indicator.connecting {
      background-color: #ffc107;
    }

    .status-indicator.disconnected {
      background-color: var(--danger-color);
    }

    .participant-count {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--secondary-color);
    }

    .action-buttons {
      display: flex;
      gap: 15px;
    }

    .btn {
      padding: 10px 20px;
      border-radius: 50px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.3s;
    }

    .btn-primary {
      background-color: var(--primary-color);
      color: white;
    }

    .btn-primary:hover {
      background-color: #3a5ad9;
    }

    .btn-danger {
      background-color: var(--danger-color);
      color: white;
    }

    .btn-danger:hover {
      background-color: #bd2130;
    }
    
    .btn-warning {
      background-color: var(--warning-color);
      color: var(--dark-color);
    }

    .btn-warning:hover {
      background-color: #e0a800;
    }
    
    .btn-chat {
      background-color: #6f42c1;
      color: white;
    }

    .btn-chat:hover {
      background-color: #5a2d91;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--secondary-color);
    }

    .empty-state i {
      font-size: 3rem;
      margin-bottom: 15px;
      color: #dee2e6;
    }

    /* Whiteboard styles */
    .whiteboard-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      display: none;
      flex-direction: column;
      z-index: 1000;
      padding: 20px;
    }

    .whiteboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background-color: var(--dark-color);
      color: white;
      border-top-left-radius: var(--border-radius);
      border-top-right-radius: var(--border-radius);
    }

    .whiteboard-container {
      flex: 1;
      background-color: white;
      border-bottom-left-radius: var(--border-radius);
      border-bottom-right-radius: var(--border-radius);
      overflow: hidden;
    }

    .whiteboard-container iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .whiteboard-controls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      justify-content: center;
    }

    /* Staff controls */
    .staff-controls {
      margin-top: 20px;
      padding: 15px;
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      display: none;
    }

    .staff-controls h3 {
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--dark-color);
      margin-bottom: 15px;
    }

    .staff-controls h3 i {
      color: var(--primary-color);
    }

    /* Chat styles */
    .chat-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 400px;
      height: 70%;
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      display: none;
      flex-direction: column;
      z-index: 1001;
      overflow: hidden;
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background-color: var(--primary-color);
      color: white;
    }

    .chat-header h3 {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chat-messages {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .message {
      max-width: 80%;
      padding: 10px 15px;
      border-radius: 18px;
      margin-bottom: 5px;
      position: relative;
      word-wrap: break-word;
    }

    .message.sent {
      align-self: flex-end;
      background-color: var(--primary-color);
      color: white;
      border-bottom-right-radius: 5px;
    }

    .message.received {
      align-self: flex-start;
      background-color: #e9e9e9;
      color: #333;
      border-bottom-left-radius: 5px;
    }

    .message-sender {
      font-size: 0.7rem;
      margin-bottom: 3px;
      opacity: 0.8;
    }

    .message-time {
      font-size: 0.6rem;
      margin-top: 5px;
      opacity: 0.7;
      text-align: right;
    }

    .chat-input-container {
      display: flex;
      padding: 15px;
      border-top: 1px solid #eee;
      gap: 10px;
    }

    .chat-input {
      flex: 1;
      padding: 12px 15px;
      border: 1px solid #ddd;
      border-radius: 50px;
      outline: none;
      font-size: 0.9rem;
    }

    .chat-input:focus {
      border-color: var(--primary-color);
    }

    .send-message-btn {
      padding: 10px 15px;
      border-radius: 50%;
      background-color: var(--primary-color);
      color: white;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .chat-notification {
      position: absolute;
      top: -5px;
      right: -5px;
      background-color: var(--danger-color);
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: bold;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .video-grid {
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      }
      
      .status-bar {
        flex-direction: column;
        gap: 15px;
        text-align: center;
      }
      
      .action-buttons {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
      }
      
      .whiteboard-overlay {
        padding: 10px;
      }
      
      .chat-overlay {
        width: 95%;
        height: 80%;
      }
    }

    @media (max-width: 480px) {
      header h1 {
        font-size: 2rem;
      }
      
      .video-grid {
        grid-template-columns: 1fr;
      }
      
      .btn {
        padding: 8px 16px;
        font-size: 0.9rem;
      }
      
      .chat-header {
        padding: 10px 15px;
      }
      
      .chat-input-container {
        padding: 10px;
      }
    }

    /* Animation for new participants */
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }

    .video-container.new {
      animation: fadeIn 0.5s ease;
    }
    
    /* Animation for new messages */
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message {
      animation: slideIn 0.3s ease;
    }

    /* Connection quality indicator */
    .connection-quality {
      display: flex;
      gap: 3px;
      margin-top: 5px;
    }

    .quality-bar {
      width: 4px;
      height: 4px;
      border-radius: 1px;
      background-color: rgba(255, 255, 255, 0.3);
    }

    .quality-bar.active {
      background-color: var(--success-color);
    }
    /* Poll-specific styles */
    .poll-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 500px;
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      display: none;
      flex-direction: column;
      z-index: 1002;
      overflow: hidden;
    }

    .poll-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background-color: var(--primary-color);
      color: white;
    }

    .poll-header h3 {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .poll-content {
      padding: 20px;
    }

    .poll-question {
      margin-bottom: 20px;
    }

    .poll-question input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
    }

    .poll-options {
      margin-bottom: 20px;
    }

    .poll-option {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .poll-option input {
      flex: 1;
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }

    .poll-option button {
      padding: 10px;
      border-radius: 8px;
      background-color: var(--danger-color);
      color: white;
      border: none;
      cursor: pointer;
    }

    .add-option {
      display: block;
      width: 100%;
      padding: 10px;
      background-color: #f0f0f0;
      border: 1px dashed #ccc;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      margin-bottom: 20px;
    }

    .add-option:hover {
      background-color: #e0e0e0;
    }

    .poll-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .active-poll {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 300px;
      background-color: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 15px;
      z-index: 999;
      display: none;
    }

    .active-poll-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .active-poll-question {
      font-weight: bold;
      margin-bottom: 10px;
    }

    .poll-option-item {
      margin-bottom: 8px;
    }

    .poll-option-button {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 12px;
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .poll-option-button:hover {
      background-color: #e0e0e0;
    }

    .poll-option-button.selected {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }

    .poll-results {
      margin-top: 15px;
      display: none;
    }

    .poll-result-item {
      margin-bottom: 8px;
    }

    .poll-result-bar {
      height: 8px;
      background-color: #e9ecef;
      border-radius: 4px;
      margin-top: 4px;
      overflow: hidden;
    }

    .poll-result-fill {
      height: 100%;
      background-color: var(--primary-color);
      border-radius: 4px;
    }

    .poll-result-text {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Multiparty Video Chat</h1>
      <p>Connect with multiple participants in real-time</p>
    </header>

    <div class="main-content">
      <div class="video-section">
        <h2><i class="fas fa-user"></i> Your Video</h2>
        <div class="video-grid">
          <div class="video-container local-video">
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="video-info">
              <span>You</span>
              <div class="video-controls">
                <button class="control-btn toggle-audio" title="Mute/Unmute Audio">
                  <i class="fas fa-microphone"></i>
                </button>
                <button class="control-btn toggle-video" title="Enable/Disable Video">
                  <i class="fas fa-video"></i>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="video-section">
        <h2><i class="fas fa-users"></i> Participants</h2>
        <div id="videos" class="video-grid">
          <div class="empty-state">
            <i class="fas fa-user-friends"></i>
            <p>Waiting for other participants to join...</p>
          </div>
        </div>
      </div>

      <!-- Staff Controls Section -->
      <div class="staff-controls" id="staffControls">
        <h3><i class="fas fa-chalkboard-teacher"></i> Staff Tools</h3>
        <div class="action-buttons">
          <button class="btn btn-warning" id="toggleWhiteboard">
            <i class="fas fa-chalkboard"></i> Open Whiteboard
          </button>
          <button class="btn btn-chat" id="createPoll">
            <i class="fas fa-poll"></i> Create Poll
          </button>
        </div>
      </div>

      <div class="status-bar">
        <div class="connection-status">
          <div class="status-indicator" id="connectionStatus"></div>
          <span id="statusText">Connecting...</span>
        </div>
        
        <div class="participant-count">
          <i class="fas fa-users"></i>
          <span id="participantCount">1 participant</span>
        </div>
        
        <div class="action-buttons">
          <button class="btn btn-chat" id="toggleChat">
            <i class="fas fa-comments"></i> Chat
            <span class="chat-notification" id="chatNotification" style="display: none;">0</span>
          </button>
          <button class="btn btn-danger" id="leaveCall">
            <i class="fas fa-phone-slash"></i> Leave Call
          </button>
          <button class="btn btn-primary" id="shareScreen">
            <i class="fas fa-desktop"></i> Share Screen
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Whiteboard Overlay -->
  <div class="whiteboard-overlay" id="whiteboardOverlay">
    <div class="whiteboard-header">
      <h3><i class="fas fa-chalkboard"></i> Collaborative Whiteboard</h3>
      <button class="control-btn" id="closeWhiteboard" title="Close Whiteboard">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="whiteboard-container">
      <iframe src="https://excalidraw.com" id="whiteboardFrame"></iframe>
    </div>
    <div class="whiteboard-controls">
      <button class="btn btn-primary" id="reloadWhiteboard">
        <i class="fas fa-sync"></i> Reload Whiteboard
      </button>
      <button class="btn btn-warning" id="clearWhiteboard">
        <i class="fas fa-trash"></i> Clear Whiteboard
      </button>
    </div>
  </div>

  <!-- Chat Overlay -->
  <div class="chat-overlay" id="chatOverlay">
    <div class="chat-header">
      <h3><i class="fas fa-comments"></i> Group Chat</h3>
      <button class="control-btn" id="closeChat" title="Close Chat">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="chat-messages" id="chatMessages">
      <div class="message received">
        <div class="message-sender">System</div>
        <div>Welcome to the chat! Start a conversation with other participants.</div>
        <div class="message-time">Just now</div>
      </div>
    </div>
    <div class="chat-input-container">
      <input type="text" class="chat-input" id="chatInput" placeholder="Type your message...">
      <button class="send-message-btn" id="sendMessage">
        <i class="fas fa-paper-plane"></i>
      </button>
    </div>
  </div>

  <!-- Poll Creation Overlay -->
  <div class="poll-overlay" id="pollOverlay">
    <div class="poll-header">
      <h3><i class="fas fa-poll"></i> Create Poll</h3>
      <button class="control-btn" id="closePoll" title="Close Poll Creator">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="poll-content">
      <div class="poll-question">
        <input type="text" id="pollQuestion" placeholder="Enter your poll question...">
      </div>
      <div class="poll-options" id="pollOptions">
        <div class="poll-option">
          <input type="text" placeholder="Option 1">
          <button class="remove-option"><i class="fas fa-times"></i></button>
        </div>
        <div class="poll-option">
          <input type="text" placeholder="Option 2">
          <button class="remove-option"><i class="fas fa-times"></i></button>
        </div>
      </div>
      <button class="add-option" id="addPollOption">
        <i class="fas fa-plus"></i> Add Option
      </button>
      <div class="poll-buttons">
        <button class="btn btn-danger" id="cancelPoll">
          Cancel
        </button>
        <button class="btn btn-primary" id="publishPoll">
          Publish Poll
        </button>
      </div>
    </div>
  </div>

  <!-- Active Poll Display -->
  <div class="active-poll" id="activePoll">
    <div class="active-poll-header">
      <h4>Live Poll</h4>
      <button class="control-btn close-poll" title="Close Poll">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="active-poll-question" id="activePollQuestion"></div>
    <div class="poll-options-list" id="pollOptionsList"></div>
    <div class="poll-results" id="pollResults">
      <div class="poll-result-text" id="pollResultText"></div>
    </div>
  </div>

  <script>
    // All existing JavaScript variables remain
    const localVideo = document.getElementById("localVideo");
    const videosContainer = document.getElementById("videos");
    const connectionStatus = document.getElementById("connectionStatus");
    const statusText = document.getElementById("statusText");
    const participantCount = document.getElementById("participantCount");
    const leaveCallBtn = document.getElementById("leaveCall");
    const shareScreenBtn = document.getElementById("shareScreen");
    const toggleAudioBtn = document.querySelector('.toggle-audio');
    const toggleVideoBtn = document.querySelector('.toggle-video');
    const staffControls = document.getElementById("staffControls");
    const toggleWhiteboardBtn = document.getElementById("toggleWhiteboard");
    const whiteboardOverlay = document.getElementById("whiteboardOverlay");
    const closeWhiteboardBtn = document.getElementById("closeWhiteboard");
    const reloadWhiteboardBtn = document.getElementById("reloadWhiteboard");
    const clearWhiteboardBtn = document.getElementById("clearWhiteboard");
    const whiteboardFrame = document.getElementById("whiteboardFrame");
    const toggleChatBtn = document.getElementById("toggleChat");
    const chatOverlay = document.getElementById("chatOverlay");
    const closeChatBtn = document.getElementById("closeChat");
    const chatMessages = document.getElementById("chatMessages");
    const chatInput = document.getElementById("chatInput");
    const sendMessageBtn = document.getElementById("sendMessage");
    const chatNotification = document.getElementById("chatNotification");
    
    // New poll-related variables
    const createPollBtn = document.getElementById("createPoll");
    const pollOverlay = document.getElementById("pollOverlay");
    const closePollBtn = document.getElementById("closePoll");
    const pollQuestion = document.getElementById("pollQuestion");
    const pollOptions = document.getElementById("pollOptions");
    const addPollOptionBtn = document.getElementById("addPollOption");
    const cancelPollBtn = document.getElementById("cancelPoll");
    const publishPollBtn = document.getElementById("publishPoll");
    const activePoll = document.getElementById("activePoll");
    const activePollQuestion = document.getElementById("activePollQuestion");
    const pollOptionsList = document.getElementById("pollOptionsList");
    const pollResults = document.getElementById("pollResults");
    const pollResultText = document.getElementById("pollResultText");
    
    let localStream;
    let peers = {}; // peerId -> RTCPeerConnection
    let pendingPeers = []; // peers received before localStream ready
    let isScreenSharing = false;
    let ws;
    let isStaff = false; // This would normally be set based on user role
    let userId = generateUserId();
    let unreadMessages = 0;
    
    // Poll state variables
    let currentPoll = null;
    let userVote = null;

    const wspolls = new WebSocket("ws://" + location.host + "/wspolls");

    // Initialize the application
    function init() {
      // For demonstration, let's assume user is staff
      // In a real application, this would be set based on authentication
      checkIfStaff();
      
      connectWebSocket();
      setupEventListeners();
      getLocalMedia();
    }

    // Generate a random user ID
    function generateUserId() {
      return 'user-' + Math.floor(Math.random() * 10000);
    }

    // Check if user is staff (for demonstration purposes)
    function checkIfStaff() {
      // In a real app, this would check user role from authentication
      // For demo, we'll use a URL parameter or prompt
      const urlParams = new URLSearchParams(window.location.search);
      isStaff = urlParams.has('staff') || confirm("Are you a staff member?");
      
      if (isStaff) {
        staffControls.style.display = 'block';
      }
    }

    // Connect to WebSocket server
    function connectWebSocket() {
      try {
        ws = new WebSocket("ws://" + location.host + "/ws");
        updateConnectionStatus('connecting');
        
        ws.onopen = () => {
          console.log("WebSocket connection established");
          updateConnectionStatus('connected');
          
          // Send user info to server
          ws.send(JSON.stringify({ 
            type: "user-info", 
            userId: userId,
            isStaff: isStaff 
          }));
        };
        
        ws.onclose = () => {
          console.log("WebSocket connection closed");
          updateConnectionStatus('disconnected');
          // Try to reconnect after 3 seconds
          setTimeout(connectWebSocket, 3000);
        };
        
        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          updateConnectionStatus('error');
        };
        
        // Handle signaling messages
        ws.onmessage = handleSignalingMessage;
        
      } catch (error) {
        console.error("Failed to connect WebSocket:", error);
        updateConnectionStatus('error');
      }
    }

    // Set up UI event listeners
    function setupEventListeners() {
      leaveCallBtn.addEventListener('click', leaveCall);
      shareScreenBtn.addEventListener('click', toggleScreenShare);
      toggleAudioBtn.addEventListener('click', toggleAudio);
      toggleVideoBtn.addEventListener('click', toggleVideo);
      
      // Whiteboard events
      if (isStaff) {
        toggleWhiteboardBtn.addEventListener('click', toggleWhiteboard);
        closeWhiteboardBtn.addEventListener('click', closeWhiteboard);
        reloadWhiteboardBtn.addEventListener('click', reloadWhiteboard);
        clearWhiteboardBtn.addEventListener('click', clearWhiteboard);
        
        // Poll events
        createPollBtn.addEventListener('click', openPollCreator);
        closePollBtn.addEventListener('click', closePollCreator);
        addPollOptionBtn.addEventListener('click', addPollOption);
        cancelPollBtn.addEventListener('click', closePollCreator);
        publishPollBtn.addEventListener('click', publishPoll);
      }
      
      // Chat events
      toggleChatBtn.addEventListener('click', toggleChat);
      closeChatBtn.addEventListener('click', closeChat);
      sendMessageBtn.addEventListener('click', sendChatMessage);
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          sendChatMessage();
        }
      });
      
      // Close active poll
      activePoll.querySelector('.close-poll').addEventListener('click', closeActivePoll);
    }

    // Get local camera/mic
    function getLocalMedia() {
      navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(stream => {
          localVideo.srcObject = stream;
          localStream = stream;
          updateMediaControls();

          // Create any pending peer connections
          pendingPeers.forEach(peerId => createPeerConnection(peerId, true));
          pendingPeers = [];
        })
        .catch(err => {
          console.error("getUserMedia error:", err);
          statusText.textContent = "Unable to access camera/microphone";
        });
    }

    // Handle signaling messages
    async function handleSignalingMessage(event) {
      const msg = JSON.parse(event.data);

      switch(msg.type) {
        case "existing-peers":
          msg.peers.forEach(peerId => {
            if(localStream) {
              createPeerConnection(peerId, true);
            } else {
              pendingPeers.push(peerId);
            }
          });
          updateParticipantCount();
          break;
          
        case "new-peer":
          if(localStream) {
            createPeerConnection(msg.id, false);
          } else {
            pendingPeers.push(msg.id);
          }
          updateParticipantCount();
          break;
          
        case "offer":
          const pc = createPeerConnection(msg.from, false);
          await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ type: "answer", answer, to: msg.from }));
          break;
          
        case "answer":
          if (peers[msg.from]) {
            await peers[msg.from].setRemoteDescription(new RTCSessionDescription(msg.answer));
          }
          break;
          
        case "ice-candidate":
          if (peers[msg.from]) {
            peers[msg.from].addIceCandidate(new RTCIceCandidate(msg.candidate));
          }
          break;
          
        case "peer-disconnected":
          removePeerConnection(msg.id);
          updateParticipantCount();
          break;
          
        case "chat-message":
          addChatMessage(msg.sender, msg.message, msg.timestamp, false);
          break;
          
        case "poll-created":
          displayPoll(msg.poll);
          break;
          
        case "poll-vote":
          updatePollResults(msg.pollId, msg.results);
          break;
          
        case "poll-ended":
          endPoll(msg.pollId, msg.finalResults);
          break;
      }
    }

    // Create peer connection
    function createPeerConnection(peerId, isOfferer) {
      if(peers[peerId]) return peers[peerId];

      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" }
        ]
      });

      // Add local tracks
      if(localStream) {
        localStream.getTracks().forEach(track => {
          if (localStream.getTracks().includes(track)) {
            pc.addTrack(track, localStream);
          }
        });
      }

      // Send ICE candidates
      pc.onicecandidate = event => {
        if(event.candidate) {
          ws.send(JSON.stringify({ type: "ice-candidate", candidate: event.candidate, to: peerId }));
        }
      };

      // Display remote stream
      pc.ontrack = event => {
        let videoElement = document.getElementById("remote-" + peerId);
        if(!videoElement) {
          // Remove empty state if it exists
          const emptyState = videosContainer.querySelector('.empty-state');
          if (emptyState) emptyState.remove();
          
          videoElement = document.createElement('video');
          videoElement.id = "remote-" + peerId;
          videoElement.autoplay = true;
          videoElement.playsInline = true;
          
          const videoContainer = document.createElement('div');
          videoContainer.className = 'video-container new';
          videoContainer.appendChild(videoElement);
          
          const videoInfo = document.createElement('div');
          videoInfo.className = 'video-info';
          videoInfo.innerHTML = `<span>Participant user</span>`;
          
          videoContainer.appendChild(videoInfo);
          videosContainer.appendChild(videoContainer);
          
          // Remove the 'new' class after animation completes
          setTimeout(() => videoContainer.classList.remove('new'), 500);
        }
        videoElement.srcObject = event.streams[0];
      };

      pc.onconnectionstatechange = () => {
        console.log(`Connection state with ${peerId}: ${pc.connectionState}`);
      };

      peers[peerId] = pc;

      // Create offer if needed
      if(isOfferer) {
        pc.createOffer().then(offer => {
          pc.setLocalDescription(offer).then(() => {
            ws.send(JSON.stringify({ type: "offer", offer, to: peerId }));
          });
        });
      }

      return pc;
    }

    // Remove peer connection
    function removePeerConnection(peerId) {
      if(peers[peerId]) {
        peers[peerId].close();
        delete peers[peerId];
      }
      
      const videoElement = document.getElementById("remote-" + peerId);
      if(videoElement) {
        videoElement.closest('.video-container').remove();
      }
      
      // Show empty state if no participants
      if(videosContainer.children.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        emptyState.innerHTML = `
          <i class="fas fa-user-friends"></i>
          <p>Waiting for other participants to join...</p>
        `;
        videosContainer.appendChild(emptyState);
      }
    }

    // Toggle audio mute/unmute
    function toggleAudio() {
      if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        if (audioTracks.length > 0) {
          const newState = !audioTracks[0].enabled;
          audioTracks[0].enabled = newState;
          
          toggleAudioBtn.classList.toggle('muted-audio', !newState);
          toggleAudioBtn.innerHTML = newState ? 
            '<i class="fas fa-microphone"></i>' : 
            '<i class="fas fa-microphone-slash"></i>';
        }
      }
    }

    // Toggle video on/off
    function toggleVideo() {
      if (localStream) {
        const videoTracks = localStream.getVideoTracks();
        if (videoTracks.length > 0) {
          const newState = !videoTracks[0].enabled;
          videoTracks[0].enabled = newState;
          
          toggleVideoBtn.classList.toggle('muted-video', !newState);
          toggleVideoBtn.innerHTML = newState ? 
            '<i class="fas fa-video"></i>' : 
            '<i class="fas fa-video-slash"></i>';
        }
      }
    }

    // Toggle screen sharing
    function toggleScreenShare() {
      if (isScreenSharing) {
        // Switch back to camera
        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
          .then(stream => {
            replaceStream(stream);
            localStream = stream;
            isScreenSharing = false;
            shareScreenBtn.innerHTML = '<i class="fas fa-desktop"></i> Share Screen';
            shareScreenBtn.classList.remove('btn-danger');
          })
          .catch(err => console.error("Error switching back to camera:", err));
      } else {
        // Switch to screen share
        navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })
          .then(stream => {
            replaceStream(stream);
            isScreenSharing = true;
            shareScreenBtn.innerHTML = '<i class="fas fa-times"></i> Stop Sharing';
            shareScreenBtn.classList.add('btn-danger');
            
            // Handle when the user stops screen sharing
            stream.getVideoTracks()[0].onended = () => {
              if (isScreenSharing) {
                toggleScreenShare();
              }
            };
          })
          .catch(err => {
            console.error("Error sharing screen:", err)
          });
      }
    }

    // Replace the current stream with a new one
    function replaceStream(newStream) {
      // Update local video element
      localVideo.srcObject = newStream;
      
      // Update all peer connections
      Object.values(peers).forEach(pc => {
        // Remove existing tracks
        const sender = pc.getSenders();
        sender.forEach(s => {
          if (s.track && s.track.kind === 'video') {
            pc.removeTrack(s);
          }
        });
        
        // Add new tracks
        newStream.getTracks().forEach(track => {
          pc.addTrack(track, newStream);
        });
      });
      
      // Close the old stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      
      localStream = newStream;
      updateMediaControls();
    }

    // Update media control buttons based on current state
    function updateMediaControls() {
      if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        const videoTracks = localStream.getVideoTracks();
        
        if (audioTracks.length > 0) {
          const audioEnabled = audioTracks[0].enabled;
          toggleAudioBtn.classList.toggle('muted-audio', !audioEnabled);
          toggleAudioBtn.innerHTML = audioEnabled ? 
            '<i class="fas fa-microphone"></i>' : 
            '<i class="fas fa-microphone-slash"></i>';
        }
        
        if (videoTracks.length > 0) {
          const videoEnabled = videoTracks[0].enabled;
          toggleVideoBtn.classList.toggle('muted-video', !videoEnabled);
          toggleVideoBtn.innerHTML = videoEnabled ? 
            '<i class="fas fa-video"></i>' : 
            '<i class="fas fa-video-slash"></i>';
        }
      }
    }

    // Toggle whiteboard visibility
    function toggleWhiteboard() {
      if (whiteboardOverlay.style.display === 'flex') {
        closeWhiteboard();
      } else {
        openWhiteboard();
      }
    }

    // Open whiteboard
    function openWhiteboard() {
      whiteboardOverlay.style.display = 'flex';
      toggleWhiteboardBtn.innerHTML = '<i class="fas fa-times"></i> Close Whiteboard';
      toggleWhiteboardBtn.classList.add('btn-danger');
      toggleWhiteboardBtn.classList.remove('btn-warning');
    }

    // Close whiteboard
    function closeWhiteboard() {
      whiteboardOverlay.style.display = 'none';
      toggleWhiteboardBtn.innerHTML = '<i class="fas fa-chalkboard"></i> Open Whiteboard';
      toggleWhiteboardBtn.classList.remove('btn-danger');
      toggleWhiteboardBtn.classList.add('btn-warning');
    }

    // Reload whiteboard
    function reloadWhiteboard() {
      whiteboardFrame.src = whiteboardFrame.src;
    }

    // Clear whiteboard
    function clearWhiteboard() {
      if (confirm("Are you sure you want to clear the whiteboard? This will remove all drawings.")) {
        // This would need to use the Excalidraw API in a real implementation
        // For now, we'll just reload it
        reloadWhiteboard();
      }
    }

    // Toggle chat visibility
    function toggleChat() {
      if (chatOverlay.style.display === 'flex') {
        closeChat();
      } else {
        openChat();
      }
    }

    // Open chat
    function openChat() {
      chatOverlay.style.display = 'flex';
      chatInput.focus();
      // Reset notification counter when chat is opened
      unreadMessages = 0;
      updateChatNotification();
    }

    // Close chat
    function closeChat() {
      chatOverlay.style.display = 'none';
    }

    // Send chat message
    function sendChatMessage() {
      const message = chatInput.value.trim();
      if (message && ws.readyState === WebSocket.OPEN) {
        const timestamp = new Date().toISOString();
        
        // Add message to UI immediately
        //addChatMessage("You", timestamp, true); // message removed
        
        // Send message to server
        ws.send(JSON.stringify({ 
          type: "chat-message", 
          sender: userId,
          message: message,
          timestamp: timestamp
        }));
        
        // Clear input
        chatInput.value = "";
      }
    }

    // Add chat message to UI
    function addChatMessage(sender, message, timestamp, isSent) {
      const messageElement = document.createElement('div');
      messageElement.className = `message ${isSent ? 'sent' : 'received'}`;
      
      const time = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      messageElement.innerHTML = `
        ${!isSent ? `<div class="message-sender">${sender}</div>` : ''}
        <div>${message}</div>
        <div class="message-time">${time}</div>
      `;
      
      chatMessages.appendChild(messageElement);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
            // Update notification if chat is not open
            if (chatOverlay.style.display !== 'flex') {
        unreadMessages++;
        updateChatNotification();
      }
    }

    // Update chat notification badge
    function updateChatNotification() {
      if (unreadMessages > 0) {
        chatNotification.textContent = unreadMessages;
        chatNotification.style.display = 'flex';
      } else {
        chatNotification.style.display = 'none';
      }
    }

    // Update connection status indicator
    function updateConnectionStatus(status) {
      connectionStatus.className = 'status-indicator';
      
      switch(status) {
        case 'connected':
          connectionStatus.classList.add('connected');
          statusText.textContent = 'Connected';
          break;
        case 'connecting':
          connectionStatus.classList.add('connecting');
          statusText.textContent = 'Connecting...';
          break;
        case 'disconnected':
          connectionStatus.classList.add('disconnected');
          statusText.textContent = 'Disconnected';
          break;
        case 'error':
          connectionStatus.classList.add('disconnected');
          statusText.textContent = 'Connection Error';
          break;
      }
    }

    // Update participant count
    function updateParticipantCount() {
      const count = Object.keys(peers).length + 1; // +1 for local user
      participantCount.textContent = `${count} participant${count !== 1 ? 's' : ''}`;
    }

    // Leave the call
    function leaveCall() {
      // Close all peer connections
      Object.keys(peers).forEach(peerId => {
        removePeerConnection(peerId);
      });
      
      // Stop local stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      
      // Close WebSocket connection
      if (ws) {
        ws.close();
      }
      
      // Update UI
      updateConnectionStatus('disconnected');
      statusText.textContent = 'Call ended';
      participantCount.textContent = '0 participants';
      
      // Disable buttons
      leaveCallBtn.disabled = true;
      shareScreenBtn.disabled = true;
      toggleAudioBtn.disabled = true;
      toggleVideoBtn.disabled = true;
      
      // Show message
      const emptyState = document.createElement('div');
      emptyState.className = 'empty-state';
      emptyState.innerHTML = `
        <i class="fas fa-phone-slash"></i>
        <p>You have left the call</p>
      `;
      videosContainer.appendChild(emptyState);
    }

    // Poll functionality
    function openPollCreator() {
      pollOverlay.style.display = 'flex';
      pollQuestion.value = '';
      
      // Clear existing options except the first two
      const options = pollOptions.querySelectorAll('.poll-option');
      for (let i = 2; i < options.length; i++) {
        options[i].remove();
      }
      
      // Reset first two options
      const firstOption = options[0].querySelector('input');
      const secondOption = options[1].querySelector('input');
      firstOption.value = '';
      secondOption.value = '';
      firstOption.placeholder = 'Option 1';
      secondOption.placeholder = 'Option 2';
    }

    function closePollCreator() {
      pollOverlay.style.display = 'none';
    }

    function addPollOption() {
      const optionCount = pollOptions.querySelectorAll('.poll-option').length;
      const optionDiv = document.createElement('div');
      optionDiv.className = 'poll-option';
      optionDiv.innerHTML = `
        <input type="text" placeholder="Option ${optionCount + 1}">
        <button class="remove-option"><i class="fas fa-times"></i></button>
      `;
      pollOptions.appendChild(optionDiv);
      
      // Add event listener to the remove button
      optionDiv.querySelector('.remove-option').addEventListener('click', function() {
        optionDiv.remove();
      });
    }

    function publishPoll() {
      const question = pollQuestion.value.trim();
      if (!question) {
        alert('Please enter a poll question');
        return;
      }
      
      const optionInputs = pollOptions.querySelectorAll('input');
      const options = [];
      
      for (let i = 0; i < optionInputs.length; i++) {
        const optionText = optionInputs[i].value.trim();
        if (optionText) {
          options.push(optionText);
        }
      }
      
      if (options.length < 2) {
        alert('Please add at least two options');
        return;
      }
      
      // Create poll object
      const pollId = 'poll-' + Date.now();
      const poll = {
        id: pollId,
        question: question,
        options: options,
        results: options.map(() => 0), // Initialize with zeros
        totalVotes: 0
      };
      
      // Send poll to server
      if (wspolls.readyState === WebSocket.OPEN) {
        wspolls.send(JSON.stringify({
          type: 'create-poll',
          poll: poll
        }));
        
        // Store current poll
        currentPoll = poll;
        
        // Close poll creator
        closePollCreator();
        
        // Display the poll for the creator
        displayPoll(poll);
      }
    }

    function displayPoll(poll) {
      activePollQuestion.textContent = poll.question;
      pollOptionsList.innerHTML = '';
      pollResults.style.display = 'none';
      
      // Create option buttons
      poll.options.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'poll-option-item';
        optionDiv.innerHTML = `
          <button class="poll-option-button" data-index="${index}">${option}</button>
        `;
        pollOptionsList.appendChild(optionDiv);
      });
      
      // Add event listeners to option buttons
      const optionButtons = pollOptionsList.querySelectorAll('.poll-option-button');
      optionButtons.forEach(button => {
        button.addEventListener('click', function() {
          if (userVote !== null) return; // Prevent voting twice
          
          const optionIndex = parseInt(this.getAttribute('data-index'));
          voteInPoll(poll.id, optionIndex);
          
          // Highlight selected option
          optionButtons.forEach(btn => btn.classList.remove('selected'));
          this.classList.add('selected');
          
          userVote = optionIndex;
        });
      });
      
      // Show the active poll
      activePoll.style.display = 'block';
      currentPoll = poll;
    }

    function voteInPoll(pollId, optionIndex) {
      if (wspolls.readyState === WebSocket.OPEN) {
        wspolls.send(JSON.stringify({
          type: 'vote-poll',
          pollId: pollId,
          optionIndex: optionIndex
        }));
      }
    }

    function updatePollResults(pollId, results) {
      if (currentPoll && currentPoll.id === pollId) {
        currentPoll.results = results;
        currentPoll.totalVotes = results.reduce((sum, count) => sum + count, 0);
        
        // Show results if user has voted
        if (userVote !== null) {
          showPollResults();
        }
      }
    }

    function showPollResults() {
      if (!currentPoll) return;
      
      pollResults.style.display = 'block';
      pollOptionsList.style.display = 'none';
      
      let resultsHTML = '';
      currentPoll.options.forEach((option, index) => {
        const voteCount = currentPoll.results[index];
        const percentage = currentPoll.totalVotes > 0 
          ? Math.round((voteCount / currentPoll.totalVotes) * 100) 
          : 0;
        
        resultsHTML += `
          <div class="poll-result-item">
            <div>${option}</div>
            <div class="poll-result-bar">
              <div class="poll-result-fill" style="width: ${percentage}%"></div>
            </div>
            <div class="poll-result-text">
              <span>${voteCount} vote${voteCount !== 1 ? 's' : ''}</span>
              <span>${percentage}%</span>
            </div>
          </div>
        `;
      });
      
      pollResults.innerHTML = resultsHTML;
      pollResultText.textContent = `Total votes: ${currentPoll.totalVotes}`;
    }

    function endPoll(pollId, finalResults) {
      if (currentPoll && currentPoll.id === pollId) {
        currentPoll.results = finalResults;
        currentPoll.totalVotes = finalResults.reduce((sum, count) => sum + count, 0);
        
        showPollResults();
        
        // Add a ended message
        const endedText = document.createElement('div');
        endedText.style.marginTop = '10px';
        endedText.style.fontWeight = 'bold';
        endedText.style.color = '#dc3545';
        endedText.textContent = 'Poll ended';
        pollResults.appendChild(endedText);
      }
    }

    function closeActivePoll() {
      activePoll.style.display = 'none';
      currentPoll = null;
      userVote = null;
    }

    // Initialize the application when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>